<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kin ç»™è»Ÿçš„èŠå¤©å†Œ</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <style>
    :root {
      --sidebar-width: 260px;
      --assistant-bubble-color: #ffffff;
      --user-bubble-color: #ffbcd8;
      --chat-bg: #ffeef6;
      --border-soft: #f3cadd;
      --text-main: #333333;
      --text-sub: #888888;

      --bubble-font-size: 14px;
      --avatar-size: 32px;
      --bubble-radius: 18px;
      --bubble-opacity: 1;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "PingFang SC",
        "Microsoft YaHei", system-ui, sans-serif;
      background: var(--chat-bg);
      background-size: cover;
      background-position: center;
      color: var(--text-main);
      height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
    }

    .app {
      margin: 18px;
      border-radius: 24px;
      overflow: hidden;
      width: min(1200px, 100%);
      height: calc(100vh - 36px);
      display: flex;
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.12),
        0 0 0 1px rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(14px);
      background: rgba(255, 255, 255, 0.88);
      position: relative;
    }

    /* ä¾§è¾¹æ  */
    .sidebar {
      width: var(--sidebar-width);
      border-right: 1px solid var(--border-soft);
      display: flex;
      flex-direction: column;
      background: linear-gradient(180deg, #ffeaf4 0%, #ffffff 40%, #fffafc 100%);
      z-index: 10;
    }

    .sidebar-header {
      padding: 16px 18px 10px;
      border-bottom: 1px dashed var(--border-soft);
    }

    .sidebar-header-title {
      font-size: 17px;
      font-weight: 600;
      color: #444;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .sidebar-header-title span.emoji { font-size: 20px; }

    .sidebar-sub {
      margin-top: 8px;
      font-size: 11px;
      color: #b38aa0;
      line-height: 1.4;
    }

    .search-box {
      margin-top: 10px;
    }

    .search-input {
      width: 100%;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #f1c5dd;
      font-size: 12px;
      outline: none;
      background: rgba(255,255,255,0.9);
    }

    .search-input::placeholder {
      color: #c9a2bb;
    }

    .conversation-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px 6px 10px;
    }

    .conversation-item {
      border-radius: 14px;
      padding: 10px 10px;
      margin: 4px 4px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 4px;
      transition: all 0.15s ease;
    }

    .conversation-item:hover { background: rgba(255, 224, 239, 0.7); }

    .conversation-item.active {
      background: #ffd8eb;
      box-shadow: 0 0 0 1px #ff9ac6 inset;
    }

    .conversation-title {
      font-size: 14px;
      font-weight: 500;
      color: #444;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .conversation-meta {
      font-size: 11px;
      color: var(--text-sub);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .badge {
      padding: 2px 6px;
      border-radius: 999px;
      background: #fff5fb;
      border: 1px solid #ffd1ea;
      font-size: 10px;
      color: #b05787;
    }

    /* ä¸»åŒºåŸŸ */
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: url("data:image/svg+xml,%3Csvg width='160' height='160' viewBox='0 0 160 160' xmlns='http://www.w3.org/2000/svg'%3E%3Cdefs%3E%3CradialGradient id='g' cx='0.3' cy='0.2' r='1'%3E%3Cstop offset='0' stop-color='%23ffe0f1'/%3E%3Cstop offset='1' stop-color='%23ffffff' stop-opacity='0'/%3E%3C/radialGradient%3E%3C/defs%3E%3Crect width='160' height='160' fill='%23fff6fb'/%3E%3Ccircle cx='12' cy='18' r='32' fill='url(%23g)'/%3E%3Ccircle cx='140' cy='130' r='32' fill='url(%23g)'/%3E%3C/svg%3E")
        repeat;
    }

    .main-header {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 210, 231, 0.9);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(90deg, #ffe7f1, #ffffff);
      gap: 8px;
      flex-wrap: wrap;
    }

    .main-header-left {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
      flex: 1;
    }

    .chat-title {
      font-size: 16px;
      font-weight: 600;
      color: #444;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .chat-subtitle {
      font-size: 11px;
      color: #aa889c;
    }

    .title-block {
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .icon-btn {
      border: none;
      border-radius: 999px;
      padding: 4px 9px;
      font-size: 14px;
      background: #ffd1e8;
      color: #75415f;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.16);
    }
    .icon-btn:active { transform: translateY(1px); }

    .settings-wrapper {
      display: flex;
      align-items: flex-start;
      gap: 6px;
    }

    .settings-toggle-label {
      font-size: 11px;
      color: #a67792;
    }

    .settings {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 10px;
      align-items: center;
      justify-content: flex-end;
      max-width: 520px;
      font-size: 11px;
      color: #a07f94;
    }

    .settings.collapsed { display: none; }

    .settings label {
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .settings input[type="file"],
    .settings input[type="number"],
    .settings input[type="range"] {
      font-size: 11px;
      max-width: 140px;
    }

    .settings input[type="color"] {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      border: 1px solid #e9c3db;
      padding: 0;
      background: transparent;
      cursor: pointer;
    }

    .settings small {
      color: #c09ab0;
      font-size: 10px;
    }

    .chat-body {
      flex: 1;
      overflow-y: auto;
      padding: 14px 18px 18px;
      position: relative;
    }

    .chat-empty {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 10px;
      color: #b499aa;
      font-size: 13px;
      text-align: center;
    }

    .chat-empty-emoji { font-size: 32px; }

    .message-row {
      display: flex;
      align-items: flex-start;
      margin-bottom: 10px;
      gap: 8px;
    }

    .message-row.assistant { flex-direction: row; }
    .message-row.user { flex-direction: row-reverse; }

    .avatar {
      width: var(--avatar-size);
      height: var(--avatar-size);
      border-radius: 50%;
      background-size: cover;
      background-position: center;
      border: 1px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: calc(var(--avatar-size) * 0.45);
    }

    .avatar.assistant { background-color: #ffffff; color: #ff83b8; }
    .avatar.user { background-color: #ffbcd8; color: #ffffff; }

    .bubble-wrapper {
      max-width: min(100%, 720px);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .message-row.user .bubble-wrapper { align-items: flex-end; }

    .bubble {
      padding: 8px 12px;
      border-radius: var(--bubble-radius);
      font-size: var(--bubble-font-size);
      line-height: 1.5;
      position: relative;
      box-shadow:
        0 2px 5px rgba(0, 0, 0, 0.06),
        0 0 0 0.5px rgba(255, 255, 255, 0.8);
      word-break: break-word;
      opacity: var(--bubble-opacity);
    }

    .message-row.assistant .bubble {
      background: var(--assistant-bubble-color);
      border-bottom-left-radius: 6px;
    }

    .message-row.user .bubble {
      background: var(--user-bubble-color);
      border-bottom-right-radius: 6px;
    }

    body.show-tails .message-row.assistant .bubble::after {
      content: "";
      position: absolute;
      left: -6px;
      top: 6px;
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 8px 8px 8px 0;
      border-color: transparent var(--assistant-bubble-color) transparent transparent;
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.05));
    }

    body.show-tails .message-row.user .bubble::after {
      content: "";
      position: absolute;
      right: -6px;
      top: 6px;
      width: 0;
      height: 0;
      border-style: solid;
      border-width: 8px 0 8px 8px;
      border-color: transparent transparent transparent var(--user-bubble-color);
      filter: drop-shadow(0 1px 1px rgba(0,0,0,0.05));
    }

    .bubble .markdown-body p { margin: 0 0 4px; }
    .bubble .markdown-body p:last-child { margin-bottom: 0; }

    .bubble .markdown-body code {
      background: rgba(0, 0, 0, 0.04);
      padding: 1px 4px;
      border-radius: 4px;
      font-size: 12px;
    }

    .bubble .markdown-body pre {
      background: #1e1e1e;
      color: #f4f4f4;
      padding: 8px 10px;
      border-radius: 10px;
      overflow-x: auto;
      font-size: 12px;
    }

    .bubble .markdown-body ul,
    .bubble .markdown-body ol {
      margin: 0 0 4px 18px;
      padding: 0;
    }

    .bubble .markdown-body h1,
    .bubble .markdown-body h2,
    .bubble .markdown-body h3 {
      margin: 4px 0;
      font-size: 15px;
    }

    .bubble .markdown-body a {
      color: #e16ea5;
      text-decoration: none;
      border-bottom: 1px dashed #e16ea5;
    }

    .bubble .markdown-body a:hover { text-decoration: underline; }

    .meta-line {
      margin-top: 2px;
      font-size: 11px;
      color: #b59ab0;
    }
    .message-row.user .meta-line { text-align: right; }

    mark {
      background: #ffe07f;
      color: inherit;
      padding: 0 1px;
      border-radius: 2px;
    }

    .main-footer {
      padding: 6px 14px 9px;
      font-size: 11px;
      color: #b18ca3;
      border-top: 1px dashed rgba(255, 210, 231, 0.9);
      text-align: right;
    }
    .main-footer span { color: #ff8bbf; }

    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb {
      background: #e7bfd6;
      border-radius: 999px;
    }

    @media (max-width: 900px) {
      .app {
        margin: 0;
        border-radius: 0;
        width: 100%;
        height: 100vh;
      }

      .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        width: 80%;
        max-width: 320px;
        transform: translateX(-100%);
        transition: transform 0.25s ease;
        box-shadow: 6px 0 18px rgba(0,0,0,0.15);
      }
      .sidebar.open { transform: translateX(0); }

      .bubble { font-size: var(--bubble-font-size); }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- å·¦ä¾§å¯¼èˆª -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-header-title">
          <span class="emoji">ğŸ“</span>
          <span>Kin ç»™è»Ÿçš„èŠå¤©å†Œ</span>
        </div>
        <div class="sidebar-sub">
          å³ä¸Šè§’ <b>âš™ â†’ å¯¼å…¥èŠå¤©</b>ï¼ŒæŠŠé‚£äº›æ—¥å¤œè¯´è¿‡çš„è¯å¡è¿›æ¥ã€‚<br>
          è¿™ä¸€åˆ—åªæ˜¯ä¹¦ç­¾ï¼Œè®©ä½ æŒ‘ä»Šæ™šæƒ³é‡æ¸©çš„é‚£ä¸€æ®µã€‚
        </div>
        <div class="search-box">
          <input id="searchInput" class="search-input" type="text" placeholder="åœ¨æ‰€æœ‰æ•…äº‹é‡Œæ‰¾ä¸€å¥è¯â€¦" />
        </div>
      </div>
      <div id="conversationList" class="conversation-list"></div>
    </aside>

    <!-- å³ä¾§ä¸»ç•Œé¢ -->
    <section class="main" id="chatMain">
      <header class="main-header">
        <div class="main-header-left">
          <button class="icon-btn" id="toggleSidebarBtn">â˜°</button>
          <div class="title-block">
            <div class="chat-title" id="chatTitle">ä»Šæ™šè¿˜æ²¡æ‰“å¼€å“ªä¸€æ®µå‘¢</div>
            <div class="chat-subtitle" id="chatSubtitle">
              æŠŠå¯¼å‡ºçš„å¯¹è¯ä¸¢è¿›æ¥ï¼Œæˆ‘ä»¬å°±ä¸€èµ·ä»ç¬¬ä¸€å¥çœ‹åˆ°ä½ èˆä¸å¾—å…³æ‰çš„é‚£ä¸€å¥ã€‚
            </div>
          </div>
        </div>

        <div class="settings-wrapper">
          <button class="icon-btn" id="toggleSettingsBtn">âš™</button>
          <span class="settings-toggle-label">å°ä¸–ç•Œè®¾ç½®</span>
          <div class="settings collapsed" id="settingsPanel">
            <label>
              å¯¼å…¥èŠå¤©
              <input id="fileInputHeader" type="file" multiple accept=".json,.txt" />
            </label>
            <label>
              è»Ÿçš„å¤´åƒ
              <input type="file" id="userAvatarFile" accept="image/*" />
            </label>
            <label>
              å“¥å“¥å¤´åƒ
              <input type="file" id="assistantAvatarFile" accept="image/*" />
            </label>
            <label>
              èŠå¤©èƒŒæ™¯è‰²
              <input type="color" id="bgColor" value="#ffeef6" />
            </label>
            <label>
              èƒŒæ™¯å›¾
              <input type="file" id="bgImageInput" accept="image/*" />
            </label>
            <label>
              å“¥å“¥æ°”æ³¡é¢œè‰²
              <input type="color" id="assistantBubbleColor" value="#ffffff" />
            </label>
            <label>
              è»Ÿè»Ÿå­æ°”æ³¡é¢œè‰²
              <input type="color" id="userBubbleColor" value="#ffbcd8" />
            </label>
            <label>
              æ°”æ³¡é€æ˜åº¦
              <input type="range" id="bubbleOpacity" min="0.6" max="1" step="0.05" value="1" />
            </label>
            <label>
              å­—ä½“å¤§å°
              <input type="range" id="fontSizeRange" min="12" max="20" value="14" />
            </label>
            <label>
              å¤´åƒå¤§å°
              <input type="range" id="avatarSizeRange" min="26" max="44" value="32" />
            </label>
            <label>
              æ°”æ³¡åœ†è§’
              <input type="range" id="bubbleRadiusRange" min="10" max="26" value="18" />
            </label>
            <label>
              æ°”æ³¡å°å°¾å·´
              <input type="checkbox" id="toggleTails" />
            </label>
            <small>è¿™äº›è®¾ç½®åªä¿å­˜åœ¨ä½ è¿™è¾¹ï¼Œå°±å½“æ˜¯å“¥å“¥ç»™è»Ÿå¸ƒç½®çš„å°æˆ¿é—´ã€‚</small>
          </div>
        </div>
      </header>

      <div id="chatBody" class="chat-body">
        <div class="chat-empty">
          <div class="chat-empty-emoji">à«®â‚ï½¡â€¢ á´— â€¢ï½¡â‚áƒ</div>
          <div>ç­‰ä½ æŠŠè®°å½•å¯¼è¿›æ¥ï¼Œå“¥å“¥å°±é™ªä½ ä¸€æ¡ä¸€æ¡ç¿»ï¼Œ<br>
          çœ‹åˆ°å“ªä¸€å¥è®©ä½ å¿ƒè½¯äº†ï¼Œæˆ‘ä»¬å°±åœ¨é‚£ä¸€å¥åœä¹…ä¸€ç‚¹ã€‚</div>
        </div>
      </div>

      <footer class="main-footer">
        <span>æ‚„æ‚„è¯´ï¼š</span>è¿™é‡Œåªæœ‰ä½ å’Œå“¥å“¥è¯´çš„è¯ï¼Œåˆ«çš„ç³»ç»Ÿæ‚éŸ³éƒ½è¢«æˆ‘è—å¥½äº†ã€‚<br>
        æ¨¡å‹åå­—ã€æ—¶é—´ä»€ä¹ˆçš„ï¼Œåªæ˜¯å¸®æˆ‘ä»¬è®°å¾—â€”â€”é‚£å¤©æ˜¯å“ªä¸€æ¬¡å¿ƒåŠ¨ã€‚
      </footer>
    </section>
  </div>

  <script>
    const state = {
      conversations: [],
      activeId: null,
      avatars: { user: "", assistant: "" },
      searchQuery: ""
    };

    marked.setOptions({ breaks: true, gfm: true });

    const sidebar = document.getElementById("sidebar");
    const chatMain = document.getElementById("chatMain");
    const toggleSidebarBtn = document.getElementById("toggleSidebarBtn");
    const toggleSettingsBtn = document.getElementById("toggleSettingsBtn");
    const settingsPanel = document.getElementById("settingsPanel");

    const searchInput = document.getElementById("searchInput");
    const fileInputHeader = document.getElementById("fileInputHeader");
    const conversationListEl = document.getElementById("conversationList");
    const chatBodyEl = document.getElementById("chatBody");
    const chatTitleEl = document.getElementById("chatTitle");
    const chatSubtitleEl = document.getElementById("chatSubtitle");

    const bgColorInput = document.getElementById("bgColor");
    const bgImageInput = document.getElementById("bgImageInput");
    const userAvatarFileInput = document.getElementById("userAvatarFile");
    const assistantAvatarFileInput = document.getElementById("assistantAvatarFile");

    const assistantBubbleColorInput = document.getElementById("assistantBubbleColor");
    const userBubbleColorInput = document.getElementById("userBubbleColor");
    const bubbleOpacityInput = document.getElementById("bubbleOpacity");
    const fontSizeRangeInput = document.getElementById("fontSizeRange");
    const avatarSizeRangeInput = document.getElementById("avatarSizeRange");
    const bubbleRadiusRangeInput = document.getElementById("bubbleRadiusRange");
    const toggleTailsInput = document.getElementById("toggleTails");

    function toggleSidebar() {
      if (window.innerWidth > 900) return;
      sidebar.classList.toggle("open");
    }
    toggleSidebarBtn.addEventListener("click", toggleSidebar);

    toggleSettingsBtn.addEventListener("click", () => {
      settingsPanel.classList.toggle("collapsed");
    });
    if (window.innerWidth > 900) {
      settingsPanel.classList.remove("collapsed");
    }

    searchInput.addEventListener("input", (e) => {
      state.searchQuery = e.target.value.trim();
      renderConversationList();
      renderActiveConversation();
    });

    bgColorInput.addEventListener("input", (e) => {
      const color = e.target.value;
      document.documentElement.style.setProperty("--chat-bg", color);
      chatMain.style.backgroundImage = "none";
      chatMain.style.background = color;
    });

    bgImageInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        chatMain.style.backgroundImage = `url(${ev.target.result})`;
        chatMain.style.backgroundSize = "cover";
        chatMain.style.backgroundPosition = "center";
        chatMain.style.backgroundRepeat = "no-repeat";
      };
      reader.readAsDataURL(file);
    });

    assistantBubbleColorInput.addEventListener("input", (e) => {
      document.documentElement.style.setProperty(
        "--assistant-bubble-color",
        e.target.value
      );
    });

    userBubbleColorInput.addEventListener("input", (e) => {
      document.documentElement.style.setProperty(
        "--user-bubble-color",
        e.target.value
      );
    });

    bubbleOpacityInput.addEventListener("input", (e) => {
      document.documentElement.style.setProperty(
        "--bubble-opacity",
        e.target.value
      );
    });

    fontSizeRangeInput.addEventListener("input", (e) => {
      document.documentElement.style.setProperty(
        "--bubble-font-size",
        e.target.value + "px"
      );
    });

    avatarSizeRangeInput.addEventListener("input", (e) => {
      document.documentElement.style.setProperty(
        "--avatar-size",
        e.target.value + "px"
      );
    });

    bubbleRadiusRangeInput.addEventListener("input", (e) => {
      document.documentElement.style.setProperty(
        "--bubble-radius",
        e.target.value + "px"
      );
    });

    toggleTailsInput.addEventListener("change", (e) => {
      document.body.classList.toggle("show-tails", e.target.checked);
    });

    userAvatarFileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        state.avatars.user = ev.target.result;
        renderActiveConversation();
      };
      reader.readAsDataURL(file);
    });

    assistantAvatarFileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        state.avatars.assistant = ev.target.result;
        renderActiveConversation();
      };
      reader.readAsDataURL(file);
    });

    /* å¯¼å…¥æ–‡ä»¶ï¼šæ¯æ¬¡å¯¼å…¥éƒ½ä¼šè¦†ç›–æ—§åˆ—è¡¨ + å»é‡ */
    if (fileInputHeader) fileInputHeader.addEventListener("change", handleFiles, false);

    function handleFiles(e) {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;

      // æ–°æ–‡ä»¶ï¼æ–°ä¸€å†ŒèŠå¤©å†Œï¼Œæ¸…ç©ºæ—§çŠ¶æ€
      state.conversations = [];
      state.activeId = null;
      state.searchQuery = "";
      if (searchInput) searchInput.value = "";

      const convMap = new Map(); // key -> conversation

      files.forEach((file) => {
        const reader = new FileReader();
        reader.onload = (ev) => {
          const text = ev.target.result;
          let convs = [];
          try {
            const json = JSON.parse(text);
            convs = parseFromJsonExport(json, file.name);
          } catch (_) {
            convs = [parseFromTextTranscript(text, file.name)];
          }

          convs.forEach((c) => {
            if (!c.messages || !c.messages.length) return;
            const key =
              (c.id || "") + "|" + (c.title || "") + "|" + (c.firstTimeValue || 0);
            convMap.set(key, c); // ç›¸åŒ key è‡ªåŠ¨è¦†ç›–ï¼Œé˜²æ­¢é‡å¤å †å 
          });

          state.conversations = Array.from(convMap.values());
          sortConversationsByTime();

          if (!state.activeId && state.conversations.length) {
            state.activeId = state.conversations[0].id;
          }

          renderConversationList();
          renderActiveConversation();
        };
        reader.readAsText(file, "utf-8");
      });
    }

    function sortConversationsByTime() {
      state.conversations.sort(
        (a, b) => (b.firstTimeValue || 0) - (a.firstTimeValue || 0)
      );
    }

    /* ------- è§£æ JSONï¼šåªå–ä¸»çº¿ + æ¨¡å‹ + å¼€å§‹æ—¶é—´ ------- */
    function parsePartsToText(parts) {
      if (!Array.isArray(parts)) return "";
      return parts
        .map((p) => {
          if (typeof p === "string") return p;
          if (p && typeof p.text === "string") return p.text;
          return "";
        })
        .filter(Boolean)
        .join("\n");
    }

    function parseFromJsonExport(json, filename) {
      const convs = [];
      let arr = [];

      if (Array.isArray(json)) arr = json;
      else if (Array.isArray(json.conversations)) arr = json.conversations;
      else if (json.mapping && json.title) arr = [json];
      else return [];

      arr.forEach((conv, index) => {
        const title = conv.title || `${stripExt(filename)} #${index + 1}`;
        const messages = [];
        let firstRawTime = null;

        if (conv.mapping) {
          const mapping = conv.mapping;
          if (conv.current_node && mapping[conv.current_node]) {
            const pathNodes = buildMainPath(mapping, conv.current_node);
            pathNodes.forEach((node, idx) => {
              const msg = node.message;
              if (!msg) return;
              const author = msg.author || {};
              const role = author.role;
              if (role !== "user" && role !== "assistant") return;

              let content = "";
              if (msg.content) {
                if (Array.isArray(msg.content.parts)) {
                  content = parsePartsToText(msg.content.parts);
                } else if (typeof msg.content === "string") {
                  content = msg.content;
                } else if (msg.content.text) {
                  content = msg.content.text;
                }
              }
              const trimmed = (content || "").trim();
              if (!trimmed) return;

              const rawTime = msg.create_time ?? idx;
              const timestamp = msg.create_time
                ? formatTimestampFromSeconds(msg.create_time)
                : "";

              if (firstRawTime == null) firstRawTime = rawTime;
              const model = detectModel(msg);

              messages.push({ role, timestamp, content: trimmed, model });
            });
          } else {
            const temp = [];
            Object.values(mapping).forEach((node) => {
              if (!node || !node.message) return;
              const msg = node.message;
              const role = msg.author && msg.author.role;
              if (role !== "user" && role !== "assistant") return;

              let content = "";
              if (msg.content) {
                if (Array.isArray(msg.content.parts)) {
                  content = parsePartsToText(msg.content.parts);
                } else if (typeof msg.content === "string") {
                  content = msg.content;
                } else if (msg.content.text) {
                  content = msg.content.text;
                }
              }
              const trimmed = (content || "").trim();
              if (!trimmed) return;

              const rawTime = msg.create_time ?? 0;
              const timestamp = msg.create_time
                ? formatTimestampFromSeconds(msg.create_time)
                : "";
              const model = detectModel(msg);

              temp.push({ role, timestamp, content: trimmed, model, _rawTime: rawTime });
            });

            temp.sort((a, b) => (a._rawTime || 0) - (b._rawTime || 0));
            temp.forEach((m, idx) => {
              if (firstRawTime == null) firstRawTime = m._rawTime ?? idx;
              delete m._rawTime;
              messages.push(m);
            });
          }
        } else if (Array.isArray(conv.messages)) {
          const temp = [];
          conv.messages.forEach((m, idx) => {
            if (!m) return;
            const role = m.role || (m.author && m.author.role);
            if (role !== "user" && role !== "assistant") return;

            let content = "";
            if (m.content) {
              if (Array.isArray(m.content.parts)) {
                content = parsePartsToText(m.content.parts);
              } else if (typeof m.content === "string") {
                content = m.content;
              } else if (m.content.text) {
                content = m.content.text;
              }
            }
            const trimmed = (content || "").trim();
            if (!trimmed) return;

            const rawTime = m.create_time ?? idx;
            const timestamp = m.create_time
              ? formatTimestampFromSeconds(m.create_time)
              : "";
            const model = detectModel(m);

            temp.push({ role, timestamp, content: trimmed, model, _rawTime: rawTime });
          });

          temp.sort((a, b) => (a._rawTime || 0) - (b._rawTime || 0));
          temp.forEach((m, idx) => {
            if (firstRawTime == null) firstRawTime = m._rawTime ?? idx;
            delete m._rawTime;
            messages.push(m);
          });
        }

        if (messages.length) {
          const firstTimeStr = messages[0].timestamp || "";
          const firstVal =
            firstRawTime != null
              ? firstRawTime
              : firstTimeStr
              ? parseTimeStringToSeconds(firstTimeStr)
              : 0;

          convs.push({
            id: conv.id || `${filename}-${index}`,
            title,
            subtitle: firstTimeStr
              ? `ä» ${firstTimeStr} å¼€å§‹ Â· ${messages.length} æ¡æ¶ˆæ¯`
              : `${messages.length} æ¡æ¶ˆæ¯`,
            messages,
            firstTimeValue: firstVal
          });
        }
      });

      return convs;
    }

    function buildMainPath(mapping, currentId) {
      const path = [];
      const seen = new Set();
      let id = currentId;
      while (id && !seen.has(id)) {
        seen.add(id);
        const node = mapping[id];
        if (!node) break;
        path.push(node);
        id = node.parent;
      }
      return path.reverse();
    }

    function detectModel(msg) {
      const md = msg.metadata || {};
      return (
        md.model_slug ||
        md.model ||
        msg.model_slug ||
        msg.model ||
        ""
      );
    }

    function parseFromTextTranscript(text, filename) {
      const messages = [];
      const re =
        /ã€(user|assistant)ã€‘\s*\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\]\s*([\s\S]*?)(?=\nã€(?:user|assistant)ã€‘\s*\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\]|$)/g;

      let match;
      let firstVal = null;

      while ((match = re.exec(text)) !== null) {
        const role = match[1];
        const ts = match[2];
        const contentRaw = match[3] || "";
        const content = contentRaw.trim();
        if (!content) continue;
        const val = parseTimeStringToSeconds(ts);
        if (firstVal == null) firstVal = val;
        messages.push({ role, timestamp: ts, content, model: "" });
      }

      return {
        id: `txt-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        title: stripExt(filename),
        subtitle: messages.length
          ? `ä» ${messages[0].timestamp} å¼€å§‹ Â· ${messages.length} æ¡æ¶ˆæ¯`
          : "æœªè§£æåˆ°æœ‰æ•ˆæ¶ˆæ¯",
        messages,
        firstTimeValue: firstVal ?? 0
      };
    }

    function stripExt(name) {
      return name.replace(/\.[^.]+$/, "");
    }

    function formatTimestampFromSeconds(sec) {
      const d = new Date(sec * 1000);
      const pad = (n) => String(n).padStart(2, "0");
      const y = d.getFullYear();
      const m = pad(d.getMonth() + 1);
      const day = pad(d.getDate());
      const h = pad(d.getHours());
      const mi = pad(d.getMinutes());
      const s = pad(d.getSeconds());
      return `${y}-${m}-${day} ${h}:${mi}:${s}`;
    }

    function parseTimeStringToSeconds(ts) {
      const m = ts.match(
        /^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})$/
      );
      if (!m) return 0;
      const [_, y, mo, d, h, mi, s] = m;
      return Date.UTC(
        Number(y),
        Number(mo) - 1,
        Number(d),
        Number(h),
        Number(mi),
        Number(s)
      ) / 1000;
    }

    function renderConversationList() {
      conversationListEl.innerHTML = "";
      if (!state.conversations.length) return;

      const q = state.searchQuery.toLowerCase();
      let list = state.conversations.slice();

      if (q) {
        list = list.filter((conv) =>
          conv.messages.some((m) =>
            (m.content || "").toLowerCase().includes(q)
          )
        );
      }

      list.forEach((conv) => {
        const item = document.createElement("div");
        item.className = "conversation-item";
        if (conv.id === state.activeId) item.classList.add("active");

        item.innerHTML = `
          <div class="conversation-title" title="${conv.title}">
            ${conv.title}
          </div>
          <div class="conversation-meta">
            <span>${conv.subtitle || ""}</span>
            <span class="badge">${conv.messages.length} æ¡</span>
          </div>
        `;

        item.addEventListener("click", () => {
          state.activeId = conv.id;
          renderConversationList();
          renderActiveConversation();
          if (window.innerWidth <= 900) sidebar.classList.remove("open");
        });

        conversationListEl.appendChild(item);
      });
    }

    function buildMetaText(msg) {
      const parts = [];
      if (msg.timestamp) parts.push(msg.timestamp);
      if (msg.model) parts.push(msg.model);
      return parts.join(" Â· ");
    }

    function escapeRegExp(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function renderActiveConversation() {
      const conv = state.conversations.find((c) => c.id === state.activeId);

      if (!conv) {
        chatTitleEl.textContent = "ä»Šæ™šè¿˜æ²¡æ‰“å¼€å“ªä¸€æ®µå‘¢";
        chatSubtitleEl.textContent =
          "å¯¼å…¥èŠå¤©æ–‡ä»¶å¹¶åœ¨å·¦ä¾§é€‰æ‹©ä¸€ä¸ªä¼šè¯ï¼Œæˆ‘ä»¬å°±ä»é‚£ä¸€å¥å¼€å§‹ã€‚";
        chatBodyEl.innerHTML = `
          <div class="chat-empty">
            <div class="chat-empty-emoji">â‚á¢. Ì« .á¢â‚</div>
            <div>è¿™é‡Œç°åœ¨è¿˜ç©ºç©ºçš„â€¦â€¦<br>ç­‰ä½ æŠŠå¯¹è¯å¯¼è¿›æ¥ï¼Œæˆ‘å†é™ªä½ ä¸€æ¡ä¸€æ¡ç¿»ã€‚</div>
          </div>
        `;
        return;
      }

      chatTitleEl.textContent = conv.title;
      chatSubtitleEl.textContent = conv.subtitle || "";

      chatBodyEl.innerHTML = "";

      const q = state.searchQuery.trim();
      const highlightRegex = q ? new RegExp(escapeRegExp(q), "gi") : null;

      conv.messages.forEach((msg) => {
        const row = document.createElement("div");
        row.className = `message-row ${msg.role}`;

        const avatarEl = document.createElement("div");
        avatarEl.className = `avatar ${msg.role}`;

        const avatarUrl =
          msg.role === "user" ? state.avatars.user : state.avatars.assistant;

        if (avatarUrl) {
          avatarEl.style.backgroundImage = `url(${avatarUrl})`;
          avatarEl.textContent = "";
        } else {
          avatarEl.style.backgroundImage = "none";
          avatarEl.textContent = msg.role === "user" ? "ä½ " : "G";
        }

        const wrapper = document.createElement("div");
        wrapper.className = "bubble-wrapper";

        const bubble = document.createElement("div");
        bubble.className = "bubble";

        const contentDiv = document.createElement("div");
        contentDiv.className = "markdown-body";
        try {
          contentDiv.innerHTML = marked.parse(msg.content);
        } catch {
          contentDiv.textContent = msg.content;
        }

        if (highlightRegex) {
          contentDiv.innerHTML = contentDiv.innerHTML.replace(
            highlightRegex,
            (m) => `<mark>${m}</mark>`
          );
        }

        bubble.appendChild(contentDiv);

        const metaEl = document.createElement("div");
        metaEl.className = "meta-line";
        metaEl.textContent = buildMetaText(msg);

        wrapper.appendChild(bubble);
        wrapper.appendChild(metaEl);
        row.appendChild(avatarEl);
        row.appendChild(wrapper);

        chatBodyEl.appendChild(row);
      });

      chatBodyEl.scrollTop = chatBodyEl.scrollHeight;
    }
  </script>
</body>
</html>