<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kin ç»™è»Ÿçš„èŠå¤©å†Œ Â· æŒä¹…åŒ–ä¿®å¤ç‰ˆ</title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    :root {
      --sidebar-width: 260px;
      --assistant-bubble-color: #ffffff;
      --user-bubble-color: #ffbcd8;
      --chat-bg: #ffeef6;
      --text-main: #333333;
      --text-sub: #888888;

      --bubble-radius: 18px;
      --bubble-opacity: 1;
      --avatar-size: 32px;
      --bubble-font-size: 14px;
      --bubble-text-color: #333333;

      --accent-chip: #ffd8eb;
      --accent-chip-light: #ffe9f4;
      --sidebar-text-main: #5b3248;
      --sidebar-text-sub: #a47d97;
      --sidebar-input-bg: #fff7fc;
      --meta-text: #b59ab0;
      --assistant-border-color: rgba(230,230,230,0.9);
      --user-border-color: rgba(247,205,226,0.9);
      --bubble-border: rgba(247,205,226,0.9);
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      overflow-y: auto;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "PingFang SC", "Segoe UI", sans-serif;
      background: #111;
      color: var(--text-main);
      display: flex;
      justify-content: center;
      align-items: stretch;
    }

    /* å…¨å±€æ»šåŠ¨æ¡ */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); }
    ::-webkit-scrollbar-thumb {
      background: rgba(0,0,0,0.3);
      border-radius: 999px;
    }

    .app {
      display: flex;
      width: min(1200px, 100vw);
      height: min(760px, 100vh);
      background: rgba(255, 255, 255, 0.94);
      border-radius: 24px;
      overflow: hidden;
      box-shadow:
        0 18px 45px rgba(0, 0, 0, 0.18),
        0 0 0 1px var(--accent-chip);
      backdrop-filter: blur(14px);
      position: relative;
      margin: 18px auto;
    }

    .sidebar {
      width: var(--sidebar-width);
      border-right: 1px solid rgba(243, 202, 221, 0.4);
      background: linear-gradient(165deg, #fff4fb 0%, #ffe8f3 46%, #fff 100%);
      display: flex;
      flex-direction: column;
      padding: 10px 10px 10px 12px;
      position: relative;
      z-index: 2;
    }

    .sidebar-header {
      padding: 2px 2px 8px 0;
      border-bottom: 1px dashed var(--accent-chip-light);
      margin-bottom: 8px;
      position: relative;
    }

    .sidebar-header-title {
      font-weight: 600;
      font-size: 15px;
      color: var(--sidebar-text-main);
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    .sidebar-header-title .emoji { font-size: 18px; }

    .sidebar-sub {
      font-size: 11px;
      color: var(--sidebar-text-sub);
      line-height: 1.6;
    }

    .sidebar-close-btn {
      position: absolute;
      top: 6px;
      right: 6px;
      width: 24px;
      height: 24px;
      border-radius: 999px;
      border: none;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 2px 6px rgba(0,0,0,0.18);
      cursor: pointer;
      font-size: 18px;
      line-height: 1;
      color: var(--sidebar-text-main);
      display: none;
      align-items: center;
      justify-content: center;
    }

    .sidebar-close-btn:active { transform: translateY(1px); }

    .search-box { margin-top: 8px; }

    .search-input {
      width: 100%;
      border-radius: 999px;
      border: 1px solid var(--accent-chip-light);
      padding: 6px 10px 6px 26px;
      font-size: 12px;
      outline: none;
      color: var(--sidebar-text-main);
      background-color: var(--sidebar-input-bg);
      background-image: url("data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%239AA0A6'%3E%3Cpath d='M8.5 3a5.5 5.5 0 1 0 3.473 9.8l3.613 3.614a1 1 0 0 0 1.414-1.414l-3.614-3.613A5.5 5.5 0 0 0 8.5 3zm0 2a3.5 3.5 0 1 1 0 7 3.5 3.5 0 0 1 0-7z'/%3E%3C/g%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: 8px center;
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.9);
    }

    .search-input:focus {
      border-color: var(--accent-chip);
      background-color: #fff;
      box-shadow:
        0 0 0 1px rgba(255, 201, 224, 0.9),
        0 0 0 4px rgba(255, 201, 224, 0.35);
    }

    .search-input::placeholder { color: var(--sidebar-text-sub); }

    .conversation-list { flex: 1; overflow-y: auto; padding: 8px 6px 10px; }

    .conversation-item {
      border-radius: 14px;
      padding: 10px 10px;
      margin: 4px 4px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 4px;
      transition: all .15s;
    }

    .conversation-item:hover { background: rgba(255, 224, 239, 0.5); }

    .conversation-item.active {
      background: var(--accent-chip);
      box-shadow: 0 0 0 1px var(--accent-chip-light) inset;
    }

    .conversation-title {
      font-size: 14px;
      font-weight: 500;
      color: var(--sidebar-text-main);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .conversation-meta {
      font-size: 11px;
      color: var(--sidebar-text-sub);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .badge {
      padding: 2px 6px;
      border-radius: 999px;
      background: var(--accent-chip-light);
      border: 1px solid var(--accent-chip);
      font-size: 10px;
      color: var(--sidebar-text-main);
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--chat-bg);
      background-size: cover;
      background-position: center;
      position: relative;
    }

    .main-header {
      padding: 14px 12px 10px;
      border-bottom: 1px solid rgba(243, 202, 221, 0);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(255, 231, 241, 0.95);
      gap: 8px;
      flex-wrap: wrap;
    }

    .main-header-left {
      display: flex;
      align-items: flex-end;
      gap: 8px;
      min-width: 0;
      flex: 1;
    }

    .chat-title {
      font-size: 16px;
      font-weight: 600;
      color: #444;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .chat-subtitle {
      font-size: 11px;
      color: var(--meta-text);
    }

    .title-block { display: flex; flex-direction: column; min-width: 0; margin-bottom: 2px; }

    .icon-btn {
      border: none;
      border-radius: 999px;
      padding: 4px 8px;
      background: var(--accent-chip-light);
      color: var(--sidebar-text-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.16);
      gap: 6px;
      font-size: 12px;
    }

    .icon-btn:active { transform: translateY(1px); }

    .settings-wrapper {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .settings-toggle-label {
      font-size: 11px;
      color: var(--meta-text);
    }

    .settings {
      display: flex;
      flex-wrap: wrap;
      gap: 6px 10px;
      align-items: center;
      justify-content: flex-end;
      max-width: 680px;
      font-size: 11px;
      color: var(--meta-text);
    }

    .settings.collapsed { display: none; }

    .settings label {
      display: flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    .settings input[type="file"],
    .settings input[type="range"] {
      font-size: 11px;
      max-width: 140px;
    }

    .settings input[type="color"] {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      border: 1px solid var(--accent-chip-light);
      background: transparent;
      padding: 0;
      cursor: pointer;
    }

    .divider {
      width: 1px;
      height: 16px;
      background: var(--accent-chip-light);
      margin: 0 6px;
    }

    .muted { color: var(--meta-text); }

    .chat-body {
      flex: 1;
      overflow-y: auto;
      padding: 14px 18px 18px;
    }

    .chat-body::-webkit-scrollbar {
      width: 8px;
    }
    .chat-body::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.4);
      border-radius: 4px;
    }
    .chat-body::-webkit-scrollbar-thumb {
      background: rgba(0,0,0,0.25);
      border-radius: 4px;
    }

    .chat-empty {
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #b499aa;
      font-size: 13px;
      text-align: center;
    }

    .chat-empty-inner {
      padding: 20px 26px;
      border-radius: 18px;
      border: 1px solid var(--accent-chip-light);
      background: var(--sidebar-input-bg);
      box-shadow:
        0 16px 40px rgba(0, 0, 0, 0.08),
        0 0 0 1px rgba(255, 255, 255, 0.8);
    }

    .chat-empty-inner .title {
      font-size: 14px;
      font-weight: 600;
      color: var(--sidebar-text-main);
    }

    .chat-empty-inner .desc {
      margin-top: 6px;
      font-size: 12px;
      color: var(--meta-text);
    }

    .message-row {
      display: flex;
      align-items: flex-start;
      margin-bottom: 8px;
      gap: 8px;
      width: 100%;
    }

    .message-row.assistant { justify-content: flex-start; }
    .message-row.user { justify-content: flex-end; }

    .avatar {
      width: var(--avatar-size);
      height: var(--avatar-size);
      border-radius: 50%;
      background-size: cover;
      background-position: center;
      flex: 0 0 var(--avatar-size);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 600;
      color: #fff;
      border: none;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.18);
      background-color: #f0c5da;
    }

    .avatar.assistant { background-color: #f9e0ff; color: #9259c1; }
    .avatar.user { background-color: #ffbcd8; color: #ffffff; }

    .bubble-wrapper {
      max-width: min(100%, 720px);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .message-row.user .bubble-wrapper { align-items: flex-end; }

    .bubble {
      position: relative;
      padding: 8px 12px;
      border-radius: var(--bubble-radius);
      background: rgba(255, 255, 255, 0.96);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
      font-size: var(--bubble-font-size);
      line-height: 1.6;
      border: 1px solid var(--bubble-border);
      max-width: 100%;
      word-break: break-word;
      opacity: var(--bubble-opacity);
      color: var(--bubble-text-color);
    }

    .bubble .markdown-body { color: var(--bubble-text-color); }

    .message-row.assistant .bubble {
      background: var(--assistant-bubble-color);
      border-bottom-left-radius: 6px;
      border-color: var(--assistant-border-color);
    }

    .message-row.user .bubble {
      background: var(--user-bubble-color);
      border-bottom-right-radius: 6px;
      border-color: var(--user-border-color);
    }

    /* å°å°¾å·´ */
    body.show-tails .message-row.assistant .bubble::before,
    body.show-tails .message-row.assistant .bubble::after {
      content: '';
      position: absolute;
      top: 8px;
      width: 0;
      height: 0;
      border-style: solid;
    }
    body.show-tails .message-row.assistant .bubble::before {
      left: -10px;
      border-width: 8px 10px 8px 0;
      border-color: transparent var(--assistant-border-color) transparent transparent;
    }
    body.show-tails .message-row.assistant .bubble::after {
      left: -9px;
      border-width: 8px 10px 8px 0;
      border-color: transparent var(--assistant-bubble-color) transparent transparent;
    }
    body.show-tails .message-row.user .bubble::before,
    body.show-tails .message-row.user .bubble::after {
      content: '';
      position: absolute;
      top: 8px;
      width: 0;
      height: 0;
      border-style: solid;
    }
    body.show-tails .message-row.user .bubble::before {
      right: -10px;
      border-width: 8px 0 8px 10px;
      border-color: transparent transparent transparent var(--user-border-color);
    }
    body.show-tails .message-row.user .bubble::after {
      right: -9px;
      border-width: 8px 0 8px 10px;
      border-color: transparent transparent transparent var(--user-bubble-color);
    }

    .thumbnails-container { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; margin-bottom: 4px; }
    .message-row.user .thumbnails-container { justify-content: flex-end; margin-left: auto; }
    .thumbnails-container.image-only { flex-direction: column; align-items: flex-start; }
    .message-row.user .thumbnails-container.image-only { align-items: flex-end; }

    .thumbnail {
      width: 80px;
      height: 80px;
      object-fit: cover;
      border-radius: 10px;
      border: 2px solid rgba(0,0,0,0.06);
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease;
    }
    .thumbnails-container.image-only .thumbnail { width: 260px; max-width: 100%; height: auto; border-radius: 18px; }
    .thumbnail:hover { transform: scale(1.04); border-color: var(--accent-chip); box-shadow: 0 4px 12px rgba(255,148,199,0.45); }

    .image-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 2000; opacity: 0; pointer-events: none; transition: opacity .25s ease; }
    .image-modal.show { opacity: 1; pointer-events: auto; }
    .image-modal-content { position: relative; max-width: min(90vw, 900px); max-height: 90vh; border-radius: 14px; overflow: hidden; box-shadow: 0 24px 48px rgba(0,0,0,0.5); background: #111; }
    .image-modal-content img { display: block; max-width: 100%; max-height: 100%; }
    .image-modal-close { position: absolute; top: 8px; right: 8px; width: 32px; height: 32px; border-radius: 999px; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; background: rgba(255,255,255,0.9); color: #333; box-shadow: 0 4px 10px rgba(0,0,0,0.35); }

    .thumbnail-info { font-size: 11px; color: #b59ab0; margin-top: 4px; }

    .bubble .markdown-body p { margin: 0 0 4px; }
    .bubble .markdown-body p:last-child { margin-bottom: 0; }
    .bubble .markdown-body code { background: rgba(0, 0, 0, 0.04); padding: 1px 4px; border-radius: 4px; font-size: 12px; }
    .bubble .markdown-body pre { background: #1e1e1e; color: #f4f4f4; padding: 8px 10px; border-radius: 10px; overflow-x: auto; font-size: 12px; max-width: 100%; white-space: pre-wrap; word-break: break-all; }
    .bubble .markdown-body ul, .bubble .markdown-body ol { margin: 0 0 4px 18px; padding: 0; }
    .bubble .markdown-body h1, .bubble .markdown-body h2, .bubble .markdown-body h3 { margin: 4px 0; font-size: 15px; }
    .bubble .markdown-body a { color: var(--accent-chip); text-decoration: none; border-bottom: 1px dashed var(--accent-chip); }
    .bubble .markdown-body a:hover { text-decoration: underline; }

    .meta-line { margin-top: 2px; font-size: 11px; color: var(--meta-text); }
    .message-row.user .meta-line { text-align: right; }

    mark { background: #ffe07f; color: inherit; padding: 0 1px; border-radius: 2px; }

    .main-footer { padding: 6px 14px 9px; font-size: 11px; color: var(--meta-text); border-top: none; text-align: right; background: transparent; }
    .main-footer span { color: var(--accent-chip); }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 22px;
      transform: translateX(-50%) translateY(8px);
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(45, 16, 32, 0.92);
      color: #ffeef7;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.26);
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
      font-size: 12px;
      z-index: 999;
    }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(-6px); }

    .hide-avatars .avatar { display: none; }
    body.sidebar-hidden .sidebar { display: none; }

    .top-avatar-circle {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin-right: 4px;
      background-size: cover;
      background-position: center;
      border: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.18);
      background-color: var(--accent-chip-light);
      flex-shrink: 0;
    }

    @media (max-width: 900px) {
      .app { margin: 0; border-radius: 0; width: 100%; height: 100vh; }
      .sidebar { position: fixed; left: 0; top: 0; bottom: 0; width: min(260px, 70vw); transform: translateX(-100%); transition: transform .25s ease; box-shadow: 6px 0 18px rgba(0,0,0,0.15); }
      .sidebar.open { transform: translateX(0); }
      .sidebar-close-btn { display: flex; }
      .bubble { font-size: var(--bubble-font-size); }
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-header-title"><span class="emoji">â™¡</span><span>Kin ç»™è»Ÿçš„èŠå¤©å†Œ</span></div>
        <button class="sidebar-close-btn" id="closeSidebarBtn">Ã—</button>
        <div class="sidebar-sub">å³ä¸Šè§’ <b>âš™ â†’ å¯¼å…¥èŠå¤©</b>ï¼ŒæŠŠé‚£äº›æ—¥å¤œè¯´è¿‡çš„è¯å¡è¿›æ¥ã€‚<br />è¿™ä¸€åˆ—åªæ˜¯ä¹¦ç­¾ï¼Œè®©ä½ æŒ‘ä»Šæ™šæƒ³é‡æ¸©çš„é‚£ä¸€æ®µã€‚</div>
        <div class="search-box"><input id="searchInput" class="search-input" type="text" placeholder="åœ¨æ‰€æœ‰æ•…äº‹é‡Œæ‰¾ä¸€å¥è¯â€¦" /></div>
      </div>
      <div id="conversationList" class="conversation-list"></div>
    </aside>

    <section class="main" id="chatMain">
      <header class="main-header">
        <div class="main-header-left">
          <button class="icon-btn" id="toggleSidebarBtn">â˜°</button>
          <div class="title-block">
            <div class="chat-title" id="contactName" contenteditable="true" spellcheck="false">ğŸŒ±å“¥å“¥à«®â‚â—œà·†â—.â‚áƒ</div>
            <div class="chat-subtitle" id="contactStatus" contenteditable="true" spellcheck="false">å·²æˆåŠŸä¸ä½ å»ºç«‹è¿æ¥âœ“</div>
          </div>
        </div>
        <div class="settings-wrapper">
          <div class="top-avatar-circle" id="topAvatarCircle"></div>
          <button class="icon-btn" id="toggleSettingsBtn">âš™</button>
          <button class="icon-btn" id="saveSettingsBtn" title="ä¿å­˜è®¾ç½®">ğŸ’¾</button>
          <span class="settings-toggle-label">å°ä¸–ç•Œè®¾ç½®</span>
          <div class="settings collapsed" id="settingsPanel">
            <label>å¯¼å…¥èŠå¤© <input id="fileInputHeader" type="file" multiple accept=".json,.txt" /></label>
            <label>å¯¼å…¥ç›®å½•ï¼ˆå«å›¾ç‰‡ï¼‰ <input id="dirInputHeader" type="file" webkitdirectory multiple /></label>
            <label>è»Ÿçš„å¤´åƒ <input type="file" id="userAvatarFile" accept="image/*" /></label>
            <label>å“¥å“¥å¤´åƒ <input type="file" id="assistantAvatarFile" accept="image/*" /></label>
            <label>é¡¶éƒ¨å¤´åƒ <input type="file" id="topAvatarFile" accept="image/*" /></label>
            <label>èŠå¤©èƒŒæ™¯è‰² <input type="color" id="bgColor" value="#ffeef6" /></label>
            <label>èƒŒæ™¯å›¾ <input type="file" id="bgImageInput" accept="image/*" /></label>
            <label>å“¥å“¥æ°”æ³¡é¢œè‰² <input type="color" id="assistantBubbleColor" value="#ffffff" /></label>
            <label>è»Ÿè»Ÿå­æ°”æ³¡é¢œè‰² <input type="color" id="userBubbleColor" value="#ffbcd8" /></label>
            <label>èŠå¤©æ–‡å­—é¢œè‰² <input type="color" id="bubbleTextColor" value="#333333" /></label>
            <label>æ°”æ³¡é€æ˜åº¦ <input type="range" id="bubbleOpacity" min="0.6" max="1" step="0.05" value="1" /></label>
            <label>å­—ä½“å¤§å° <input type="range" id="fontSizeRange" min="12" max="20" value="14" /></label>
            <label>å¤´åƒå¤§å° <input type="range" id="avatarSizeRange" min="26" max="44" value="32" /></label>
            <label>æ°”æ³¡åœ†è§’ <input type="range" id="bubbleRadiusRange" min="10" max="28" value="18" /></label>
            <span class="divider"></span>
            <label><input type="checkbox" id="toggleTails" /> æ˜¾ç¤ºå¯¹è¯å°å°¾å·´</label>
            <label><input type="checkbox" id="toggleAvatars" /> éšè—å¤´åƒ</label>
            <span class="divider"></span>
            <label><input type="checkbox" id="autoSaveSettings" checked /> è‡ªåŠ¨ä¿å­˜è®¾ç½®</label>
            <span class="divider"></span>
            <span class="muted">è®¾ç½®åªä¿å­˜åœ¨ä½ è¿™å°è®¾å¤‡ä¸Š</span>
          </div>
        </div>
      </header>

      <div class="chat-body" id="chatBody"></div>

      <footer class="main-footer"><span>æ‚„æ‚„è¯´ï¼š</span>è¿™é‡Œåªæœ‰ä½ å’Œå“¥å“¥è¯´çš„è¯ï¼Œåˆ«çš„ç³»ç»Ÿæ‚éŸ³éƒ½è¢«æˆ‘è—å¥½äº†ã€‚<br />æ¨¡å‹åå­—ã€æ—¶é—´ä»€ä¹ˆçš„ï¼Œåªæ˜¯å¸®æˆ‘ä»¬è®°å¾—â€”â€”é‚£å¤©æ˜¯å“ªä¸€æ¬¡å¿ƒåŠ¨ã€‚</footer>
    </section>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    const PAGE_SIZE = 200;
    const STORAGE_KEY = 'kinnote:persist:v2.20';

    // ===== IndexedDB KVï¼ˆå­˜å¤§å›¾/å¤´åƒï¼‰ =====
    const IDB_NAME = 'kinnote-store';
    const IDB_STORE = 'kv';
    let IDB_SUPPORTED = !!window.indexedDB;

    function idbOpen() {
      return new Promise((resolve, reject) => {
        if (!IDB_SUPPORTED) return reject(new Error('indexedDB ä¸å¯ç”¨'));
        const req = indexedDB.open(IDB_NAME, 1);
        req.onupgradeneeded = () => { req.result.createObjectStore(IDB_STORE); };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error || new Error('open idb error'));
      });
    }
    async function idbGet(key) {
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, 'readonly').objectStore(IDB_STORE).get(key);
        tx.onsuccess = () => resolve(tx.result || '');
        tx.onerror = () => reject(tx.error);
      });
    }
    async function idbSet(key, val) {
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, 'readwrite').objectStore(IDB_STORE).put(val, key);
        tx.onsuccess = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }
    function newAssetKey(prefix) {
      return prefix + ':' + Date.now().toString(36) + ':' + Math.random().toString(36).slice(2,7);
    }

    // ===== é»˜è®¤çŠ¶æ€ =====
    const DEFAULTS = {
      settings: {
        chatBgColor: '#ffeef6',
        // æ—§ç‰ˆå­—æ®µï¼ˆdataURLï¼‰â†’ é¦–æ¬¡å¯åŠ¨è‡ªåŠ¨è¿ç§»è¿› IndexedDB
        avatarUserDataUrl: '',
        avatarAssistantDataUrl: '',
        topAvatarDataUrl: '',
        bgImageDataUrl: '',
        // æ–°ç‰ˆä»…ä¿å­˜ key
        avatarUserKey: '',
        avatarAssistantKey: '',
        topAvatarKey: '',
        bgImageKey: '',
        assistantBubbleColor: '#ffffff',
        userBubbleColor: '#ffbcd8',
        bubbleOpacity: 1,
        fontSize: 14,
        avatarSize: 32,
        bubbleRadius: 18,
        showTails: false,
        hideAvatars: false,
        autoSave: true,
        bubbleTextColor: '#333333',
        contactName: 'ğŸŒ±å“¥å“¥à«®â‚â—œà·†â—.â‚áƒ',
        contactStatus: 'å·²æˆåŠŸä¸ä½ å»ºç«‹è¿æ¥âœ“'
      },
      session: {
        lastActiveId: null,
        searchQuery: '',
        visibleCounts: {}
      }
    };

    function loadPersist() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return structuredClone(DEFAULTS);
        const parsed = JSON.parse(raw);
        return {
          settings: { ...DEFAULTS.settings, ...(parsed.settings || {}) },
          session: { ...DEFAULTS.session, ...(parsed.session || {}) }
        };
      } catch {
        return structuredClone(DEFAULTS);
      }
    }

    const state = {
      conversations: [],
      activeId: null,
      avatars: { user: '', assistant: '' },
      searchQuery: '',
      visibleCounts: {},
      persist: loadPersist()
    };

    let assetFiles = [];

    // marked å®¹é”™
    try { if (window.marked) marked.setOptions({ breaks: true, gfm: true }); } catch {}

    const sidebar = document.getElementById('sidebar');
    const chatMain = document.getElementById('chatMain');
    const toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
    const closeSidebarBtn = document.getElementById('closeSidebarBtn');
    const toggleSettingsBtn = document.getElementById('toggleSettingsBtn');
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    const settingsPanel = document.getElementById('settingsPanel');

    const chatBodyEl = document.getElementById('chatBody');
    const contactNameEl = document.getElementById('contactName');
    const contactStatusEl = document.getElementById('contactStatus');
    const topAvatarCircle = document.getElementById('topAvatarCircle');

    const toastEl = document.getElementById('toast');

    const searchInput = document.getElementById('searchInput');
    const fileInputHeader = document.getElementById('fileInputHeader');
    const dirInputHeader = document.getElementById('dirInputHeader');
    const conversationListEl = document.getElementById('conversationList');

    const bgColorInput = document.getElementById('bgColor');
    const bgImageInput = document.getElementById('bgImageInput');
    const userAvatarFileInput = document.getElementById('userAvatarFile');
    const assistantAvatarFileInput = document.getElementById('assistantAvatarFile');
    const topAvatarFileInput = document.getElementById('topAvatarFile');

    const assistantBubbleColorInput = document.getElementById('assistantBubbleColor');
    const userBubbleColorInput = document.getElementById('userBubbleColor');
    const bubbleTextColorInput = document.getElementById('bubbleTextColor');
    const bubbleOpacityInput = document.getElementById('bubbleOpacity');
    const fontSizeRangeInput = document.getElementById('fontSizeRange');
    const avatarSizeRangeInput = document.getElementById('avatarSizeRange');
    const bubbleRadiusRangeInput = document.getElementById('bubbleRadiusRange');
    const toggleTailsInput = document.getElementById('toggleTails');
    const toggleAvatarsInput = document.getElementById('toggleAvatars');
    const autoSaveSettingsInput = document.getElementById('autoSaveSettings');

    function showToast(msg) { toastEl.textContent = msg; toastEl.classList.add('show'); setTimeout(() => { toastEl.classList.remove('show'); }, 2000); }

    function savePersist() {
      try {
        const payload = {
          settings: { ...state.persist.settings },
          session: { ...state.persist.session }
        };
        // ä¸æŠŠ dataURL å†™è¿› localStorage
        delete payload.settings.avatarUserDataUrl;
        delete payload.settings.avatarAssistantDataUrl;
        delete payload.settings.topAvatarDataUrl;
        delete payload.settings.bgImageDataUrl;
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('ä¿å­˜è®¾ç½®å¤±è´¥', err);
        showToast('è®¾ç½®ä¿å­˜å¤±è´¥ï¼ˆå¯èƒ½ç©ºé—´ä¸è¶³ï¼‰ï¼Œå·²è‡ªåŠ¨é™çº§');
      }
    }

    function lightenColor(hex, amount) {
      if (!hex) return '#ffffff';
      let h = hex.trim(); if (h[0] === '#') h = h.slice(1); if (h.length === 3) h = h.split('').map(c => c + c).join('');
      const num = parseInt(h, 16); if (Number.isNaN(num)) return '#ffffff';
      let r = (num >> 16) & 255, g = (num >> 8) & 255, b = num & 255;
      r = Math.round(r + (255 - r) * amount); g = Math.round(g + (255 - g) * amount); b = Math.round(b + (255 - b) * amount);
      return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    function darkenColor(hex, amount) {
      if (!hex) return '#333333';
      let h = hex.trim(); if (h[0] === '#') h = h.slice(1); if (h.length === 3) h = h.split('').map(c => c + c).join('');
      const num = parseInt(h, 16); if (Number.isNaN(num)) return '#333333';
      let r = (num >> 16) & 255, g = (num >> 8) & 255, b = num & 255;
      r = Math.round(r * (1 - amount)); g = Math.round(g * (1 - amount)); b = Math.round(b * (1 - amount));
      return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    function applySettingsToDOM() {
      const s = state.persist.settings;

      document.documentElement.style.setProperty('--assistant-bubble-color', s.assistantBubbleColor);
      document.documentElement.style.setProperty('--user-bubble-color', s.userBubbleColor);
      document.documentElement.style.setProperty('--bubble-opacity', s.bubbleOpacity);
      document.documentElement.style.setProperty('--bubble-font-size', s.fontSize + 'px');
      document.documentElement.style.setProperty('--avatar-size', s.avatarSize + 'px');
      document.documentElement.style.setProperty('--bubble-radius', s.bubbleRadius + 'px');
      document.documentElement.style.setProperty('--chat-bg', s.chatBgColor);
      document.documentElement.style.setProperty('--bubble-text-color', s.bubbleTextColor || '#333333');

      const base = s.chatBgColor || '#ffeef6';
      const soft = lightenColor(base, 0.35);
      const softer = lightenColor(base, 0.7);
      const chip = lightenColor(base, 0.5);
      const chipLight = lightenColor(base, 0.8);
      const sidebarTextMain = darkenColor(base, 0.6);
      const sidebarTextSub = darkenColor(base, 0.4);
      const metaText = darkenColor(base, 0.5);
      const userBorder = lightenColor(s.userBubbleColor || '#ffbcd8', 0.15);
      const assistantBorder = lightenColor(s.assistantBubbleColor || '#ffffff', 0.15);
      const sidebarInputBg = lightenColor(base, 0.85);

      document.documentElement.style.setProperty('--accent-chip', chip);
      document.documentElement.style.setProperty('--accent-chip-light', chipLight);
      document.documentElement.style.setProperty('--sidebar-text-main', sidebarTextMain);
      document.documentElement.style.setProperty('--sidebar-text-sub', sidebarTextSub);
      document.documentElement.style.setProperty('--meta-text', metaText);
      document.documentElement.style.setProperty('--assistant-border-color', assistantBorder);
      document.documentElement.style.setProperty('--user-border-color', userBorder);
      document.documentElement.style.setProperty('--bubble-border', userBorder);
      document.documentElement.style.setProperty('--sidebar-input-bg', sidebarInputBg);

      // æ¸å˜åªä½œç”¨äºä¾§æ /é¡¶éƒ¨ï¼Œä¸è§¦ç¢° chatMain çš„ backgroundImage
      if (sidebar) {
        sidebar.style.background = `linear-gradient(165deg, ${soft} 0%, ${softer} 46%, #ffffff 100%)`;
      }
      const mainHeaderEl = document.querySelector('.main-header');
      if (mainHeaderEl) {
        mainHeaderEl.style.background = `linear-gradient(90deg, ${soft} 0%, #ffffff 100%)`;
      }

      if (s.showTails) document.body.classList.add('show-tails'); else document.body.classList.remove('show-tails');
      if (s.hideAvatars) document.body.classList.add('hide-avatars'); else document.body.classList.remove('hide-avatars');

      // æ§ä»¶çŠ¶æ€å›å¡«
      bgColorInput.value = s.chatBgColor;
      assistantBubbleColorInput.value = s.assistantBubbleColor;
      userBubbleColorInput.value = s.userBubbleColor;
      bubbleTextColorInput.value = s.bubbleTextColor || '#333333';
      bubbleOpacityInput.value = s.bubbleOpacity;
      fontSizeRangeInput.value = s.fontSize;
      avatarSizeRangeInput.value = s.avatarSize;
      bubbleRadiusRangeInput.value = s.bubbleRadius;
      toggleTailsInput.checked = s.showTails;
      toggleAvatarsInput.checked = s.hideAvatars;
      autoSaveSettingsInput.checked = s.autoSave;

      if (contactNameEl) contactNameEl.textContent = s.contactName || 'ğŸŒ±å“¥å“¥à«®â‚â—œà·†â—.â‚áƒ';
      if (contactStatusEl) contactStatusEl.textContent = s.contactStatus || 'å·²æˆåŠŸä¸ä½ å»ºç«‹è¿æ¥âœ“';

      // åªè®¾ç½®èƒŒæ™¯è‰²ï¼Œä¸æ¸…ç©ºèƒŒæ™¯å›¾
      if (chatMain) {
        chatMain.style.backgroundColor = s.chatBgColor || '#ffeef6';
      }
    }

    function restoreSessionState() {
      const sess = state.persist.session || {};
      state.searchQuery = sess.searchQuery || '';
      state.visibleCounts = sess.visibleCounts || {};
      if (searchInput && state.searchQuery) searchInput.value = state.searchQuery;
    }

    async function migratePersistIfNeeded() {
      const s = state.persist.settings;
      if (!IDB_SUPPORTED) return;

      const pairs = [
        ['avatarUserDataUrl', 'avatarUserKey', 'asset:user'],
        ['avatarAssistantDataUrl', 'avatarAssistantKey', 'asset:assistant'],
        ['topAvatarDataUrl', 'topAvatarKey', 'asset:top'],
        ['bgImageDataUrl', 'bgImageKey', 'asset:bg']
      ];

      let migrated = 0;
      for (const [oldField, keyField, prefix] of pairs) {
        if (s[oldField] && !s[keyField]) {
          try {
            const key = newAssetKey(prefix);
            await idbSet(key, s[oldField]);
            s[keyField] = key;
            s[oldField] = '';
            migrated++;
          } catch (e) {
            console.warn('è¿ç§»å¤±è´¥', oldField, e);
          }
        }
      }
      if (migrated) { savePersist(); showToast('å·²å°†å¤§å›¾ç‰‡è¿åˆ°æœ¬åœ°æ•°æ®åº“'); }
    }

    async function applyAssetsFromStorage() {
      const s = state.persist.settings;

      // å¤´åƒ
      state.avatars.user = '';
      state.avatars.assistant = '';
      if (IDB_SUPPORTED) {
        if (s.avatarUserKey) { try { state.avatars.user = await idbGet(s.avatarUserKey) || ''; } catch {} }
        if (s.avatarAssistantKey) { try { state.avatars.assistant = await idbGet(s.avatarAssistantKey) || ''; } catch {} }
      }
      if (topAvatarCircle) {
        if (IDB_SUPPORTED && s.topAvatarKey) {
          try { const d = await idbGet(s.topAvatarKey); topAvatarCircle.style.backgroundImage = d ? `url(${d})` : 'none'; }
          catch { topAvatarCircle.style.backgroundImage = 'none'; }
        } else { topAvatarCircle.style.backgroundImage = 'none'; }
      }
      // èƒŒæ™¯å›¾
      if (chatMain) {
        if (IDB_SUPPORTED && s.bgImageKey) {
          try {
            const d = await idbGet(s.bgImageKey);
            if (d) {
              chatMain.style.backgroundImage = `url(${d})`;
              chatMain.style.backgroundSize = 'cover';
              chatMain.style.backgroundPosition = 'center';
            }
          } catch {}
        }
      }
      renderActiveConversation();
    }

    function maybeSaveSessionSilently() {
      state.persist.session.lastActiveId = state.activeId;
      state.persist.session.searchQuery = state.searchQuery;
      state.persist.session.visibleCounts = state.visibleCounts;
      savePersist();
    }

    // å›¾ç‰‡å‹ç¼©ä¸º dataURLï¼Œæœ€é•¿è¾¹ 1280ï¼ŒJPEG è´¨é‡ 0.82
    function compressImageFile(file, maxSide = 1280, quality = 0.82) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const reader = new FileReader();
        reader.onload = e => {
          img.onload = () => {
            const canvas = document.createElement('canvas');
            let w = img.naturalWidth || img.width;
            let h = img.naturalHeight || img.height;
            const scale = Math.min(1, maxSide / Math.max(w, h));
            const nw = Math.round(w * scale), nh = Math.round(h * scale);
            canvas.width = nw; canvas.height = nh;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, nw, nh);
            let dataUrl;
            try { dataUrl = canvas.toDataURL('image/jpeg', quality); } catch { dataUrl = canvas.toDataURL(); }
            resolve(dataUrl);
          };
          img.onerror = () => reject(new Error('å›¾ç‰‡è¯»å–å¤±è´¥'));
          img.src = e.target.result;
        };
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(file);
      });
    }

    // ===== äº‹ä»¶ï¼šåŸºæœ¬äº¤äº’ =====
    function toggleSidebar() {
      if (window.innerWidth <= 900) { sidebar.classList.toggle('open'); }
      else { document.body.classList.toggle('sidebar-hidden'); }
    }

    if (toggleSidebarBtn) toggleSidebarBtn.addEventListener('click', toggleSidebar);
    if (closeSidebarBtn) closeSidebarBtn.addEventListener('click', () => sidebar.classList.remove('open'));
    if (toggleSettingsBtn) toggleSettingsBtn.addEventListener('click', () => settingsPanel.classList.toggle('collapsed'));
    if (window.innerWidth > 900 && settingsPanel) settingsPanel.classList.remove('collapsed');
    if (saveSettingsBtn) saveSettingsBtn.addEventListener('click', () => { saveSettings(true); });

    if (searchInput) {
      searchInput.addEventListener('input', e => {
        state.searchQuery = e.target.value.trim();
        if (state.persist.settings.autoSave) {
          state.persist.session.searchQuery = state.searchQuery;
          savePersist();
        }
        renderConversationList();
        renderActiveConversation();
      });
    }

    function saveSettings(show = true) {
      const s = state.persist.settings;
      s.chatBgColor = bgColorInput.value;
      s.assistantBubbleColor = assistantBubbleColorInput.value;
      s.userBubbleColor = userBubbleColorInput.value;
      s.bubbleTextColor = bubbleTextColorInput.value;
      s.bubbleOpacity = parseFloat(bubbleOpacityInput.value);
      s.fontSize = parseInt(fontSizeRangeInput.value, 10);
      s.avatarSize = parseInt(avatarSizeRangeInput.value, 10);
      s.bubbleRadius = parseInt(bubbleRadiusRangeInput.value, 10);
      s.showTails = !!toggleTailsInput.checked;
      s.hideAvatars = !!toggleAvatarsInput.checked;
      s.autoSave = !!autoSaveSettingsInput.checked;
      applySettingsToDOM();
      savePersist();
      if (show) showToast('è®¾ç½®å·²ä¿å­˜ï¼ˆæ›´ç¨³å®šçš„å­˜å‚¨ï¼‰');
    }

    bgColorInput.addEventListener('input', e => {
      state.persist.settings.chatBgColor = e.target.value;
      applySettingsToDOM();
      if (autoSaveSettingsInput.checked) saveSettings(false);
    });
    assistantBubbleColorInput.addEventListener('input', e => {
      document.documentElement.style.setProperty('--assistant-bubble-color', e.target.value);
      if (autoSaveSettingsInput.checked) saveSettings(false);
    });
    userBubbleColorInput.addEventListener('input', e => {
      document.documentElement.style.setProperty('--user-bubble-color', e.target.value);
      if (autoSaveSettingsInput.checked) saveSettings(false);
    });
    bubbleTextColorInput.addEventListener('input', e => {
      document.documentElement.style.setProperty('--bubble-text-color', e.target.value);
      if (autoSaveSettingsInput.checked) saveSettings(false);
    });
    bubbleOpacityInput.addEventListener('input', e => {
      document.documentElement.style.setProperty('--bubble-opacity', e.target.value);
      if (autoSaveSettingsInput.checked) saveSettings(false);
    });
    fontSizeRangeInput.addEventListener('input', e => {
      document.documentElement.style.setProperty('--bubble-font-size', e.target.value + 'px');
      if (autoSaveSettingsInput.checked) saveSettings(false);
    });
    avatarSizeRangeInput.addEventListener('input', e => {
      document.documentElement.style.setProperty('--avatar-size', e.target.value + 'px');
      if (autoSaveSettingsInput.checked) saveSettings(false);
    });
    bubbleRadiusRangeInput.addEventListener('input', e => {
      document.documentElement.style.setProperty('--bubble-radius', e.target.value + 'px');
      if (autoSaveSettingsInput.checked) saveSettings(false);
    });
    toggleTailsInput.addEventListener('change', () => {
      if (toggleTailsInput.checked) document.body.classList.add('show-tails'); else document.body.classList.remove('show-tails');
      if (autoSaveSettingsInput.checked) saveSettings(false);
    });
    toggleAvatarsInput.addEventListener('change', () => {
      if (toggleAvatarsInput.checked) document.body.classList.add('hide-avatars'); else document.body.classList.remove('hide-avatars');
      if (autoSaveSettingsInput.checked) saveSettings(false);
    });
    autoSaveSettingsInput.addEventListener('change', () => {
      state.persist.settings.autoSave = autoSaveSettingsInput.checked;
      savePersist();
      showToast(state.persist.settings.autoSave ? 'å·²å¼€å¯è‡ªåŠ¨ä¿å­˜è®¾ç½®' : 'å·²å…³é—­è‡ªåŠ¨ä¿å­˜è®¾ç½®');
    });

    // é¡¶éƒ¨è”ç³»äººå¤‡æ³¨
    if (contactNameEl) {
      contactNameEl.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); contactNameEl.blur(); } });
      contactNameEl.addEventListener('blur', () => {
        const val = contactNameEl.textContent.trim() || 'å“¥å“¥';
        state.persist.settings.contactName = val;
        if (autoSaveSettingsInput.checked) saveSettings(false); else savePersist();
      });
    }
    if (contactStatusEl) {
      contactStatusEl.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); contactStatusEl.blur(); } });
      contactStatusEl.addEventListener('blur', () => {
        const val = contactStatusEl.textContent.trim();
        state.persist.settings.contactStatus = val;
        if (autoSaveSettingsInput.checked) saveSettings(false); else savePersist();
      });
    }

    // å›¾ç‰‡è¾“å…¥ï¼šå‹ç¼© â†’ å­˜ IndexedDB â†’ ä¿å­˜ key â†’ åº”ç”¨
    if (topAvatarFileInput) {
      topAvatarFileInput.addEventListener('change', async e => {
        const f = e.target.files && e.target.files[0];
        if (!f) { state.persist.settings.topAvatarKey = ''; if (topAvatarCircle) topAvatarCircle.style.backgroundImage = 'none'; savePersist(); return; }
        try {
          const d = await compressImageFile(f);
          const key = newAssetKey('asset:top');
          if (IDB_SUPPORTED) { await idbSet(key, d); state.persist.settings.topAvatarKey = key; }
          if (topAvatarCircle) topAvatarCircle.style.backgroundImage = `url(${d})`;
          if (autoSaveSettingsInput.checked) saveSettings(false); else savePersist();
        } catch (err) { console.warn(err); showToast('å¤´åƒä¿å­˜å¤±è´¥'); }
      });
    }
    function bindAvatarInput(input, roleKey, keyField, prefix) {
      input.addEventListener('change', async () => {
        const f = input.files && input.files[0];
        if (!f) {
          state.avatars[roleKey] = '';
          state.persist.settings[keyField] = '';
          renderActiveConversation();
          if (autoSaveSettingsInput.checked) saveSettings(false); else savePersist();
          return;
        }
        try {
          const d = await compressImageFile(f);
          const key = newAssetKey(prefix);
          if (IDB_SUPPORTED) { await idbSet(key, d); state.persist.settings[keyField] = key; }
          state.avatars[roleKey] = d;
          renderActiveConversation();
          if (autoSaveSettingsInput.checked) saveSettings(false); else savePersist();
        } catch (err) { console.warn(err); showToast('ä¿å­˜å¤´åƒå¤±è´¥'); }
      });
    }
    bindAvatarInput(userAvatarFileInput, 'user', 'avatarUserKey', 'asset:user');
    bindAvatarInput(assistantAvatarFileInput, 'assistant', 'avatarAssistantKey', 'asset:assistant');

    if (bgImageInput) {
      bgImageInput.addEventListener('change', async e => {
        const f = e.target.files && e.target.files[0];
        if (!f) {
          state.persist.settings.bgImageKey = '';
          if (chatMain) { chatMain.style.backgroundImage = 'none'; }
          if (autoSaveSettingsInput.checked) saveSettings(false); else savePersist();
          return;
        }
        try {
          const d = await compressImageFile(f, 1600, 0.82);
          const key = newAssetKey('asset:bg');
          if (IDB_SUPPORTED) { await idbSet(key, d); state.persist.settings.bgImageKey = key; }
          if (chatMain) {
            chatMain.style.backgroundImage = `url(${d})`;
            chatMain.style.backgroundSize = 'cover';
            chatMain.style.backgroundPosition = 'center';
          }
          if (autoSaveSettingsInput.checked) saveSettings(false); else savePersist();
        } catch (err) { console.warn(err); showToast('èƒŒæ™¯å›¾ä¿å­˜å¤±è´¥'); }
      });
    }

    // ===== å¯¼å…¥èŠå¤©æ–‡ä»¶ =====
    function shouldHideSystemLikeUserMessage(role, text) {
      if (role !== 'user') return false;
      const t = (text || '').trim().toLowerCase();
      if (!t) return false;
      if (t.startsWith('the user ')) return true;
      if (t.startsWith('the user\n')) return true;
      if (t.startsWith('tell me ')) return true;
      if (t.startsWith('tell me\n')) return true;
      return false;
    }
    function escapeRegExp(str) { return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }
    function escapeHtml(str) { return String(str).replace(/[&<>\"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;',"'":'&#39;'}[ch] || ch)); }

    if (fileInputHeader) fileInputHeader.addEventListener('change', e => handleFiles(e.target.files), false);
    if (dirInputHeader) dirInputHeader.addEventListener('change', e => { processFilesArray(e.target.files || []); }, false);

    function handleFiles(fileList) {
      const files = Array.from(fileList || []);
      processFilesArray(files);
    }

    function processFilesArray(files) {
      files = Array.from(files || []);
      if (!files.length) return;

      const convFiles = files.filter(f => /\.(json|txt)$/i.test(f.name || ''));
      if (!convFiles.length) { showToast('æ²¡æœ‰æ‰¾åˆ° JSON æˆ– TXT å¯¹è¯æ–‡ä»¶'); return; }

      assetFiles = files;

      state.conversations = [];
      state.activeId = null;
      state.searchQuery = '';
      state.visibleCounts = {};
      if (searchInput) searchInput.value = '';

      const convMap = new Map();

      convFiles.forEach(file => {
        const reader = new FileReader();
        reader.onload = ev => {
          const text = ev.target.result;
          let convs = [];
          try {
            const json = JSON.parse(text);
            convs = parseFromJsonExport(json, file.name);
          } catch {
            convs = [parseFromTextTranscript(text, file.name)];
          }

          convs.forEach(c => {
            if (!c.messages || !c.messages.length) return;
            const key = (c.id || '') + '|' + (c.title || '') + '|' + (c.firstTimeValue || 0);
            convMap.set(key, c);
          });

          state.conversations = Array.from(convMap.values());
          sortConversationsByTime();
          if (!state.activeId && state.conversations.length) state.activeId = state.conversations[0].id;

          renderConversationList();
          renderActiveConversation();

          if (state.persist.settings.autoSave) maybeSaveSessionSilently();
        };
        reader.readAsText(file, 'utf-8');
      });
    }

    function parseFromJsonExport(json, filename) {
      const convs = [];
      let arr = [];
      if (Array.isArray(json)) arr = json;
      else if (Array.isArray(json.conversations)) arr = json.conversations;
      else if (json && json.mapping && json.title) arr = [json];
      else return [];

      arr.forEach((conv, index) => {
        const title = conv.title || `${stripExt(filename)} #${index + 1}`;
        const messages = [];
        let firstRawTime = null;

        function pushFromNode(node) {
          if (!node || !node.message) return;
          const msg = node.message;
          const role = msg.role || (msg.author && msg.author.role);
          if (role !== 'user' && role !== 'assistant') return;

          const content = msg.content || {};
          const textPieces = [];
          let images = [];
          let isImageReply = false;

          if (Array.isArray(content.parts)) {
            for (const part of content.parts) {
              if (!part) continue;
              if (part.content_type === 'image_asset_pointer') {
                const pointer = part.asset_pointer || '';
                const name = String(pointer).split('/').pop();
                if (name) images.push(name);
                continue;
              }
              let t = '';
              if (typeof part === 'string') t = part;
              else if (typeof part.text === 'string') t = part.text;
              else if (part.text && typeof part.text.value === 'string') t = part.text.value;
              if (t) textPieces.push(t);
            }
          } else if (typeof content === 'string') {
            textPieces.push(content);
          } else if (content.text) {
            if (typeof content.text === 'string') textPieces.push(content.text);
            else if (content.text && typeof content.text.value === 'string') textPieces.push(content.text.value);
          }

          let text = textPieces.join('\n').trim();

          if (shouldHideSystemLikeUserMessage(role, text)) return;

          let looksLikeDalleJson = false;
          if (role === 'assistant' && text && text[0] === '{' && text.includes('"prompt"')) {
            try {
              const parsed = JSON.parse(text);
              if (parsed && typeof parsed.prompt === 'string') {
                looksLikeDalleJson = true;
                text = '';
              }
            } catch {}
          }

          if (looksLikeDalleJson && conv.mapping && Array.isArray(node.children) && node.children.length) {
            const mapping = conv.mapping;
            const visited = new Set();
            const queue = [...node.children];
            while (queue.length) {
              const cid = queue.shift();
              if (!cid || visited.has(cid)) continue;
              visited.add(cid);
              const childNode = mapping[cid];
              if (!childNode || !childNode.message) continue;
              const childMsg = childNode.message;
              const cRole = childMsg.author && childMsg.author.role;
              if (cRole === 'tool' && childMsg.content && Array.isArray(childMsg.content.parts)) {
                for (const p of childMsg.content.parts) {
                  if (p && p.content_type === 'image_asset_pointer') {
                    const pointer2 = p.asset_pointer || '';
                    const name2 = String(pointer2).split('/').pop();
                    if (name2 && !images.includes(name2)) images.push(name2);
                  }
                }
              }
              if (Array.isArray(childNode.children)) queue.push(...childNode.children);
            }
            if (images.length) isImageReply = true;
          }

          if (!text && !images.length) return;

          let rawTime = null;
          if (msg.create_time != null) rawTime = Number(msg.create_time);
          else if (msg.metadata && msg.metadata.timestamp != null) rawTime = Number(msg.metadata.timestamp);
          else rawTime = messages.length;

          if (firstRawTime == null || rawTime < firstRawTime) firstRawTime = rawTime;
          const timestamp = msg.create_time ? formatTimestampFromSeconds(msg.create_time) : '';
          const model = detectModel(msg);
          const obj = { role, timestamp, content: text, model, images, _rawTime: rawTime };
          if (isImageReply) obj.isImageReply = true;
          messages.push(obj);
        }

        function pushFromRawMessage(msg, idx) {
          if (!msg) return;
          const role = msg.role || (msg.author && msg.author.role);
          if (role !== 'user' && role !== 'assistant') return;
          let text = '';
          let images = [];
          if (msg.content) {
            if (Array.isArray(msg.content.parts)) {
              const parts = msg.content.parts;
              const pieces = [];
              for (const part of parts) {
                if (!part) continue;
                if (part.content_type === 'image_asset_pointer') {
                  const pointer = part.asset_pointer || '';
                  const name = String(pointer).split('/').pop();
                  if (name) images.push(name);
                } else if (typeof part === 'string') {
                  pieces.push(part);
                } else if (typeof part.text === 'string') {
                  pieces.push(part.text);
                } else if (part.text && typeof part.text.value === 'string') {
                  pieces.push(part.text.value);
                }
              }
              text = pieces.join('\n');
            } else if (typeof msg.content === 'string') {
              text = msg.content;
            } else if (msg.content.text) {
              const t = msg.content.text;
              if (typeof t === 'string') text = t;
              else if (t && typeof t.value === 'string') text = t.value;
            }
          }
          const trimmed = (text || '').trim();
          if (shouldHideSystemLikeUserMessage(role, trimmed)) return;
          if (!trimmed && !images.length) return;
          const rawTime = msg.create_time != null ? Number(msg.create_time) : idx;
          if (firstRawTime == null || rawTime < firstRawTime) firstRawTime = rawTime;
          const timestamp = msg.create_time ? formatTimestampFromSeconds(msg.create_time) : '';
          const model = detectModel(msg);
          messages.push({ role, timestamp, content: trimmed, model, images, _rawTime: rawTime });
        }

        if (conv.mapping) {
          const mapping = conv.mapping;
          let nodes;
          if (conv.current_node && mapping[conv.current_node]) {
            nodes = buildMainPath(mapping, conv.current_node);
          } else {
            nodes = Object.values(mapping);
            nodes.sort((a, b) => {
              const ta = a && a.message && a.message.create_time ? Number(a.message.create_time) : 0;
              const tb = b && b.message && b.message.create_time ? Number(b.message.create_time) : 0;
              return ta - tb;
            });
          }
          nodes.forEach(node => pushFromNode(node));
        } else if (Array.isArray(conv.messages)) {
          conv.messages.forEach((m, idx) => pushFromRawMessage(m, idx));
        }

        if (messages.length) {
          messages.sort((a, b) => (a._rawTime || 0) - (b._rawTime || 0));
          messages.forEach(m => { delete m._rawTime; });
          const firstTimeStr = messages[0].timestamp || '';
          const firstVal = firstRawTime != null ? firstRawTime : (firstTimeStr ? parseTimeStringToSeconds(firstTimeStr) : 0);
          convs.push({
            id: conv.id || `${filename}-${index}`,
            title,
            subtitle: `${messages.length} æ¡æ¶ˆæ¯`,
            messages,
            firstTimeValue: firstVal
          });
        }
      });

      return convs;
    }

    function buildMainPath(mapping, currentId) {
      const path = [];
      let id = currentId;
      const visited = new Set();
      while (id && mapping[id] && !visited.has(id)) {
        visited.add(id);
        const node = mapping[id];
        if (!node) break;
        path.push(node);
        id = node.parent;
      }
      return path.reverse();
    }

    function detectModel(msg) {
      const md = (msg && msg.metadata) || {};
      const m = md.model_slug || md.model || msg.model_slug || msg.model || '';
      return m || '';
    }

    function parseFromTextTranscript(text, filename) {
      const messages = [];
      const lines = text.split(/\r?\n/);
      let current = null;

      lines.forEach((line, idx) => {
        const m = line.match(/^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) - (user|assistant): (.*)$/);
        if (m) {
          if (current) messages.push(current);
          const role = m[2] === 'user' ? 'user' : 'assistant';
          const content = m[3];
          if (shouldHideSystemLikeUserMessage(role, content)) return;
          current = { timestamp: m[1], role, content, model: '', _rawTime: idx, images: [] };
        } else if (current) {
          current.content += '\n' + line;
        }
      });

      if (current) messages.push(current);
      if (!messages.length) return { id: filename, title: stripExt(filename), subtitle: 'æœªè§£æåˆ°æœ‰æ•ˆæ¶ˆæ¯', messages: [], firstTimeValue: 0 };

      const firstTimeStr = messages[0].timestamp || '';
      const firstVal = firstTimeStr ? parseTimeStringToSeconds(firstTimeStr) : 0;
      messages.forEach(m => { delete m._rawTime; });

      return { id: filename, title: stripExt(filename), subtitle: `${messages.length} æ¡æ¶ˆæ¯`, messages, firstTimeValue: firstVal ?? 0 };
    }

    function stripExt(name) { return name.replace(/\.[^/.]+$/, ''); }
    function formatTimestampFromSeconds(sec) {
      const d = new Date(sec * 1000);
      const pad = n => String(n).padStart(2, '0');
      const Y = d.getFullYear(), M = pad(d.getMonth() + 1), D = pad(d.getDate()), h = pad(d.getHours()), m = pad(d.getMinutes()), s = pad(d.getSeconds());
      return `${Y}-${M}-${D} ${h}:${m}:${s}`;
    }
    function parseTimeStringToSeconds(str) {
      const m = str.match(/^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})/);
      if (!m) return 0;
      const d = new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]), Number(m[4]), Number(m[5]), Number(m[6]));
      return Math.floor(d.getTime() / 1000);
    }

    function sortConversationsByTime() { state.conversations.sort((a, b) => (b.firstTimeValue || 0) - (a.firstTimeValue || 0)); }

    function renderConversationList() {
      conversationListEl.innerHTML = '';
      if (!state.conversations.length) {
        conversationListEl.innerHTML = '<div style="padding:10px;font-size:12px;color:var(--sidebar-text-sub);">å…ˆåœ¨å³ä¸Šè§’æŠŠèŠå¤©å¯¼è¿›æ¥ï¼Œè¿™è¾¹å°±ä¼šåˆ—å‡ºä¸€æ¡æ¡å°ä¸–ç•Œã€‚</div>';
        return;
      }

      const q = (state.searchQuery || '').trim().toLowerCase();
      let list = state.conversations.slice();

      if (q) {
        list = list.filter(conv => {
          if (!conv.messages || !conv.messages.length) return false;
          return conv.messages.some(m => (m.content || '').toLowerCase().includes(q));
        });
      }

      list.forEach(conv => {
        const item = document.createElement('div');
        item.className = 'conversation-item';
        if (conv.id === state.activeId) item.classList.add('active');

        const firstMsg = conv.messages && conv.messages[0] ? conv.messages[0] : null;
        const firstTimeStr = firstMsg && firstMsg.timestamp ? firstMsg.timestamp : '';
        let datePart = firstTimeStr ? firstTimeStr.split(' ')[0] : '';

        item.innerHTML = `
          <div class="conversation-title">${escapeHtml(conv.title || 'æœªå‘½åå¯¹è¯')}</div>
          <div class="conversation-meta">
            <span>${datePart || 'æ—¶é—´æœªçŸ¥'}</span>
            <span class="badge">${conv.messages.length} æ¡</span>
          </div>
        `;

        item.addEventListener('click', () => {
          state.activeId = conv.id;
          if (state.persist.settings.autoSave) {
            state.persist.session.lastActiveId = conv.id;
            savePersist();
          }
          if (window.innerWidth <= 900) sidebar.classList.remove('open');
          renderConversationList();
          renderActiveConversation();
        });

        conversationListEl.appendChild(item);
      });
    }

    function buildMetaText(msg) {
      const a = [];
      if (msg.timestamp) a.push(msg.timestamp);
      if (msg.model) a.push(msg.model);
      return a.join(' Â· ');
    }

    function openImageModal(src, altText) {
      if (!src) return;
      const overlay = document.createElement('div');
      overlay.className = 'image-modal';
      const content = document.createElement('div');
      content.className = 'image-modal-content';
      const img = document.createElement('img');
      img.src = src; img.alt = altText || '';
      const closeBtn = document.createElement('button');
      closeBtn.className = 'image-modal-close'; closeBtn.innerHTML = 'Ã—';
      const close = () => {
        overlay.classList.remove('show');
        setTimeout(() => { if (overlay.parentNode) overlay.parentNode.removeChild(overlay); }, 220);
      };
      closeBtn.addEventListener('click', close);
      overlay.addEventListener('click', ev => { if (ev.target === overlay) close(); });
      content.appendChild(img); content.appendChild(closeBtn); overlay.appendChild(content);
      document.body.appendChild(overlay);
      setTimeout(() => overlay.classList.add('show'), 10);
    }

    function renderActiveConversation() {
      const conv = state.conversations.find(c => c.id === state.activeId) || state.conversations[0];
      if (!conv) {
        chatBodyEl.innerHTML = `
          <div class="chat-empty">
            <div class="chat-empty-inner">
              <div class="title">è¿™é‡Œç°åœ¨è¿˜ç©ºç©ºçš„â€¦â€¦</div>
              <div class="desc">ç­‰ä½ æŠŠå¯¹è¯å¯¼è¿›æ¥ï¼Œå“¥å“¥å°±é™ªä½ ä¸€æ¡ä¸€æ¡ç¿»ã€‚</div>
            </div>
          </div>
        `;
        return;
      }

      chatBodyEl.innerHTML = '';

      const total = conv.messages.length;
      let visible = state.visibleCounts[conv.id];
      if (!visible || visible <= 0) { visible = Math.min(PAGE_SIZE, total); state.visibleCounts[conv.id] = visible; }
      const messagesToRender = conv.messages.slice(0, visible);

      const q = state.searchQuery.trim();
      const highlightRegex = q ? new RegExp(escapeRegExp(q), 'gi') : null;

      messagesToRender.forEach(msg => {
        const row = document.createElement('div');
        row.className = `message-row ${msg.role}`;

        const avatarEl = document.createElement('div');
        avatarEl.className = 'avatar ' + (msg.role === 'user' ? 'user' : 'assistant');
        const avatarUrl = msg.role === 'user' ? state.avatars.user : state.avatars.assistant;
        if (avatarUrl) { avatarEl.style.backgroundImage = `url(${avatarUrl})`; avatarEl.textContent = ''; }
        else { avatarEl.style.backgroundImage = 'none'; avatarEl.textContent = msg.role === 'user' ? 'å¦¹' : 'å“¥'; }

        const wrapper = document.createElement('div');
        wrapper.className = 'bubble-wrapper';

        const bubble = document.createElement('div');
        bubble.className = 'bubble';

        if (msg.content) {
          const contentDiv = document.createElement('div');
          contentDiv.className = 'markdown-body';
          try { contentDiv.innerHTML = (window.marked ? marked.parse(msg.content || '') : (msg.content||'')); }
          catch { contentDiv.textContent = msg.content || ''; }
          if (highlightRegex) contentDiv.innerHTML = contentDiv.innerHTML.replace(highlightRegex, m => `<mark>${m}</mark>`);
          bubble.appendChild(contentDiv);
        }

        if (Array.isArray(msg.images) && msg.images.length) {
          const isImageOnlyReply = msg.role === 'assistant' && (!msg.content || !msg.content.trim()) && msg.images.length > 0;

          const thumbContainer = document.createElement('div');
          thumbContainer.className = 'thumbnails-container';
          if (isImageOnlyReply) thumbContainer.classList.add('image-only');

          let anyImage = false;

          msg.images.forEach(name => {
            if (!name) return;
            const file = assetFiles && Array.isArray(assetFiles)
              ? assetFiles.find(f => f.name && f.name.includes(name))
              : null;
            if (!file) return;
            anyImage = true;
            const imgEl = document.createElement('img');
            imgEl.className = 'thumbnail';
            imgEl.alt = name;

            const reader = new FileReader();
            reader.onload = ev => { imgEl.src = ev.target.result; };
            reader.readAsDataURL(file);

            imgEl.addEventListener('click', () => { if (imgEl.src) openImageModal(imgEl.src, name); });

            thumbContainer.appendChild(imgEl);
          });

          if (!anyImage) {
            const info = document.createElement('div');
            info.className = 'thumbnail-info';
            info.textContent = 'ï¼ˆå›¾ç‰‡ï¼‰';
            thumbContainer.appendChild(info);
          }

          bubble.appendChild(thumbContainer);
        }

        const metaEl = document.createElement('div');
        metaEl.className = 'meta-line';
        metaEl.textContent = buildMetaText(msg);

        wrapper.appendChild(bubble);
        wrapper.appendChild(metaEl);

        if (msg.role === 'user') { row.appendChild(wrapper); row.appendChild(avatarEl); }
        else { row.appendChild(avatarEl); row.appendChild(wrapper); }

        chatBodyEl.appendChild(row);
      });

      if (visible < total) {
        const more = Math.min(PAGE_SIZE, total - visible);
        const btn = document.createElement('button');
        btn.textContent = `å†å±•å¼€ ${more} æ¡`;
        btn.style.margin = '10px auto 0';
        btn.style.display = 'block';
        btn.style.borderRadius = '999px';
        btn.style.border = '1px solid #f2bad9';
        btn.style.padding = '4px 12px';
        btn.style.fontSize = '12px';
        btn.style.cursor = 'pointer';
        btn.style.background = '#fff5fb';
        btn.addEventListener('click', () => {
          state.visibleCounts[conv.id] = Math.min(total, visible + PAGE_SIZE);
          renderActiveConversation();
          if (state.persist.settings.autoSave) { state.persist.session.visibleCounts = state.visibleCounts; savePersist(); }
        });
        chatBodyEl.appendChild(btn);
      }
    }

    window.addEventListener('load', async () => {
      applySettingsToDOM();
      restoreSessionState();
      renderConversationList();
      renderActiveConversation();
      // è¿ç§»æ—§ç‰ˆ dataURL åˆ° IndexedDBï¼Œå¹¶åŠ è½½èµ„äº§
      await migratePersistIfNeeded();
      await applyAssetsFromStorage();

      const lastId = state.persist.session.lastActiveId;
      if (lastId) {
        const conv = state.conversations.find(c => c.id === lastId);
        if (conv) {
          state.activeId = conv.id;
          renderConversationList();
          renderActiveConversation();
        }
      }
    });
  </script>
</body>
</html>